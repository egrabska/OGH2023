---
title: "Environmental analysis using satellite image time series in R"
author: "Ewa Grabska-Szwagrzyk"
output:
  html_document:
    theme: united
    highlight: tango
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
## Part 1: Pre-processing and smoothing satellite image time series
### Loading and pre-processing data

Load the packages:
```{r message=FALSE, warning=FALSE}
if (!require("pacman")) install.packages("pacman")
pacman::p_load("tidyverse", "tsibble", "bfast", "data.table", "mgcv","forecast", 
               "anytime", "fabletools", "signal", "fable", "tibble",
               "sits", "gdalcubes")
```


Import data - raw MTCI values from Sentinel-2 acquired from GEE:
```{r}
df = read.csv("d:/geohub/species_mtci.csv")
str(df)
summary(df)
```

As you can see, there is a lot of NA values, also, if we plot index values there are a lot of outliers. 
```{r}
plot(df$MTCI)
```


Modify column with date and change columns names:
```{r message=FALSE, warning=FALSE}
df$system.index = as.Date(df$system.index, format =  "%Y%m%d")
names(df) = c("date", "index", "type")
```

Filtering values, removing NA, mean of duplicates:
```{r message=FALSE, warning=FALSE}
df_clean = df %>% 
  drop_na() %>%
  group_by(date, type) %>%
  summarise(index = mean(index)) %>% 
  ungroup() %>%
  dplyr::filter(index < 7 & index > 0 & date > "2018-03-05") 

ggplot(df_clean, aes(date, index, color = type))+
  geom_point()+
  theme_light()
```


### Example analysis on hornbeam (GB) time series

```{r message=FALSE, warning=FALSE}
df_gb = df_clean %>%
  dplyr::filter(type == "GB")
ggplot(df_gb, aes(date, index))+
  geom_line(color = "darkgreen", linewidth = 1)+
  theme_light()
```

Firstly, identify and replace outliers using simple linear interpolation:
```{r}
df_gb$index_out = df_gb$index %>% 
  tsclean()

ggplot(df_gb)+
  geom_point(aes(date, index), color = "red")+
  geom_point(aes(date, index_out), color = "darkgreen")+
  theme_light()
```

### Smoothing 1: Simple Moving Average 

```{r message=FALSE, warning=FALSE}
df_gb$avg3 = rollmean(df_gb$index_out ,3, fill = NA)
df_gb$avg10 = rollmean(df_gb$index_out ,10, fill = NA)

ggplot(df_gb)+
  geom_line(aes(date, index_out))+
  geom_line(aes(date, avg3), color = "blue", linewidth = 1.0)+
  geom_line(aes(date, avg10), color = "red", linewidth = 1.0)+
  theme_light()
```

### Smoothing 2: Savitzky-Golay smoothing

We need to create regular (1-day) time series with NA for missing values.

```{r message=FALSE, warning=FALSE}
df_bfast = bfastts(df_gb$index_out, df_gb$date, type = ("irregular"))
df_tibble = tibble(date = seq(as.Date(df_gb$date[1]), by = "day", 
                              length.out = length(df_bfast)), value = df_bfast) %>%
  as_tsibble(index = date) 
```

Interpolation of unknown values using ARIMA fitting (The ARIMA() model requires equal spacing between observations)

```{r message=FALSE, warning=FALSE}
df_inter = df_tibble %>% 
  model(arima = ARIMA(value ~ -1 + pdq(0,1,0) + PDQ(0,0,0))) %>% 
  interpolate(df_tibble)
```

Apply Savitzky-Golay filter. n is a filter length (odd number) - test different values.
```{r message=FALSE, warning=FALSE}
df_inter$sg = df_inter$value %>%
  sgolayfilt(n = 71) 
```  


Analyze the results on plot - line represent time series smoothed by S-G, red dots - original values and blue dots - interpolated values
```{r message=FALSE, warning=FALSE}
df_inter$original = df_tibble$value
ggplot(df_inter)+
  geom_point(aes(date, value), color = "blue", alpha = 0.3)+
  geom_point(aes(date, original), color = "red", alpha = 0.4)+
  geom_line(aes(date, sg), linewidth = 1)+
  theme_light()
```

### Smoothing 3: Generalized Additive Models (GAM) fitting

The first step is the same as in Savitzky-Golay - we will create regular time series with NA values:
```{r message=FALSE, warning=FALSE}
df_bfast = bfastts(df_gb$index_out, df_gb$date, type = ("irregular"))
df_tibble = tibble(date = seq(as.Date(df_gb$date[1]), by = "day", 
                              length.out = length(df_bfast)), value = df_bfast) %>%
  as_tsibble(index = date) %>%
  ts() %>% #but here also we need to change date format from y-m-d to 
  as.data.frame()
```

But now we can go straight to modelling without dealing with missing values!

GAM modelling with dates as predictor (Generalized Additive Mixed Models):
```{r message=FALSE, warning=FALSE}
model = gamm(df_tibble$value ~ s(date, k = 60), 
             data = df_tibble, method = "REML")
```

Predicting values using GAM model and plotting the results:
```{r message=FALSE, warning=FALSE}
df_tibble$predicted = predict.gam(model$gam, df_tibble)
df_tibble$date =  anydate(df_tibble$date)

ggplot(df_tibble)+
  geom_point(aes(date, value), color = "red", alpha = 0.4)+
  geom_line(aes(date, predicted), linewidth = 1)+
  theme_light()
```

Compare S-G (blue line) and GAM (black line):
```{r message=FALSE, warning=FALSE}
df_tibble$sg = df_inter$sg

ggplot(df_tibble)+
  geom_point(aes(date, value), color = "red", alpha = 0.4)+
  geom_line(aes(date, predicted), alpha = 0.8, linewidth = 1)+
  geom_line(aes(date, sg), color = "blue", alpha = 0.8, linewidth = 1)+
  theme_light()
```


## Part 2: Detecting trends and breaks
In this part we will use Savitzky-Golay smoothing and then try to detect breaks and trends in satellite time series for the part of PoznaÅ„ 

### Checking and smoothing selected pixels (samples)
Load the data (already pre-processed:)
```{r message=FALSE, warning=FALSE} 
df = read.csv("d:/geohub/poznan_ndvi_clean.csv")
str(df)
summary(df)
df = df[,-1]
df$system.index = as.Date(df$system.index, format = "%Y-%m-%d")
names(df) = c("date", "pointid", "index")


ggplot(sample_n(df, 5000), aes(date, index))+
  geom_point(alpha = 0.5)+
  theme_light()
```

Check examples examples with pointid 551 - vegetation development; 1311 and 472 - new built-up; 1623 conifer trees; 1149 built up to green space
```{r message=FALSE, warning=FALSE} 
df_sel = df %>%
  dplyr::filter(pointid %in% c(472, 551,1149,1311, 1623))

ggplot(df_sel, aes(date, index, 
                   group = pointid, color = as.factor(pointid)))+
  geom_line(linewidth = 1, alpha = 0.6)+
  scale_color_manual(values = c("#FF6666", "green", "purple", "#FF9900", "darkgreen"))+
  theme_light()
```

Let's now check the just the place with vegetation development and than smooth the time series: 
```{r message=FALSE, warning=FALSE} 
df_sel = df %>%
  dplyr::filter(pointid %in% c(551))
ggplot(df_sel, aes(date, index, 
                   group = pointid, color = as.factor(pointid)))+
  geom_line(linewidth = 1)+
  theme_light()
```

Based on previous part, we will use Savitzky-Golay smoothing - to make it easier you can find the function with all necessary steps (e.g. producing regular time series) and applying S-G function. The input for this is id (pointid in our loaded dataframe) and input_df, with ...
```{r message=FALSE, warning=FALSE} 
sg = function(id, input_df) {
  df_sel = input_df %>%
    dplyr::filter(pointid == id)
  df_bfast = bfastts(df_sel$index, df_sel$date, type = ("irregular"))
  df_tibble = tibble(date = seq(as.Date(df_sel$date[1]), by = "day", 
                                length.out = length(df_bfast)), value = df_bfast) %>%
    as_tsibble(index = date) 
  df_inter = df_tibble %>% 
    model(arima = ARIMA(value ~ -1 + pdq(0,1,0) + PDQ(0,0,0))) %>% 
    interpolate(df_tibble)
  df_inter$sg = df_inter$value %>%
    sgolayfilt(n = 91) # n is a filter length
  df_inter$id = id
  return(df_inter[,-2])
}


sg(1068, df) %>%
  ggplot()+
  geom_line(aes(date, sg), 
            alpha = 0.8, linewidth = 1)+
  theme_light()

```

### Time series decomposition

First example - new built-up area:
```{r message=FALSE, warning=FALSE} 
df_sg = sg(1068, df)

df_sg_ts = df_sg[,c(1,2)] %>%
  ts(frequency = 365)

df_sg_ts[,2] %>% decompose() %>%
  plot()
```

Second example - vegetation development:
```{r message=FALSE, warning=FALSE} 
df_sg = sg(551, df)

df_sg_ts = df_sg[,c(1,2)] %>%
  ts(frequency = 365)

df_sg_ts[,2] %>% decompose() %>%
  plot()
```

Different method - stl: Seasonal Decomposition of Time Series by Loess:
```{r message=FALSE, warning=FALSE} 
df_sg_ts[,2] %>% 
  stl(t.window=13, s.window="periodic", robust=TRUE) %>%
  plot()
```


### Detecting breaks 

Detect breaks using bfast function - firstly, apply S-G smoothing (the data should be a regular ts() object without NAs). This is the example for pixel no 1311.
```{r message=FALSE, warning=FALSE}

change1 = sg(1311, df) %>%
  select(date, sg) %>%
  ts(frequency = 365)
```

Use bfast function - which is an iterative break detection in seasonal and trend component of a time series; plot the results and the detected break date:
```{r message=FALSE, results='hide', warning=FALSE}
fit = bfast(change1[,2], h = 0.01, season = "harmonic", max.iter = 1, breaks = 1) 
plot(fit)
```
```{r message=FALSE, warning=FALSE}
anydate(change1[1] + fit$Time)
```


And another example 
```{r message=FALSE, results='hide', warning=FALSE}

change1 = sg(472, df) %>%
  select(date, sg) %>%
  ts(frequency = 365)
fit = bfast(change1[,2], h = 0.01, season = "harmonic", max.iter = 1, breaks = 1) 
plot(fit)
```
```{r message=FALSE, warning=FALSE}
anydate(change1[1] + fit$Time)
```

Then these results can be, for example, joined with spatial data - and we can produce map of new built-up areas, like in the example below. Still, method is not perfect, you can try testing other parameters! :) 



## Part 3: SITS package 



